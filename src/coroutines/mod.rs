use crate::error::*;
use crate::fiber::*;
use crate::future::closure::*;
use crate::future::{self, future, Cancel, Complete, Future, Progress, ReqPtr, Request};
use crate::impls::async_fn::*;
use crate::macros::{assert_unsafe_precondition, unreachable_unchecked};
pub use crate::macros::{asynchronous, join, select};
use crate::opt::hint::*;
use crate::pointer::*;
use crate::runtime::{self, call_no_unwind, catch_unwind_safe, MaybePanic};
use crate::{debug, trace, warn};

mod lang {}

pub mod branch;
use branch::*;

pub mod closure;
pub mod context;
pub mod executor;
pub mod join;
pub mod select;
pub mod spawn;
pub mod worker;

pub use context::*;
pub use executor::*;
pub use join::*;
pub use select::*;
pub use spawn::*;
pub use worker::*;

/* The budget for async tasks */
pub const DEFAULT_BUDGET: u32 = 128;

/// An async task is a value that might not have finished computing yet. This
/// kind of “asynchronous value” makes it possible for a thread to continue
/// doing useful work while it waits for the value to become available
#[asynchronous]
#[lang = "task"]
#[must_use = "Task does nothing until you `.await` it"]
pub trait Task {
	type Output<'ctx>;

	/// # Safety
	/// The task must be able to suspend
	///
	/// See [`scoped`] for more information
	async fn run(self) -> Self::Output<'_>;
}

#[doc(hidden)]
pub mod internal {
	use super::*;

	pub fn as_task<T, Output>(task: T) -> impl for<'ctx> Task<Output<'ctx> = Output>
	where
		T: for<'ctx> Task<Output<'ctx> = Output>
	{
		task
	}

	#[inline(always)]
	pub fn unsafe_stub_do_not_use<T>(context: &Context, task: T) -> T::Output<'_>
	where
		T: Task
	{
		/* Safety: this function is a stub generated by macros only in an async
		 * function. it is an error to call this function from anywhere else
		 */
		unsafe { context.run(task) }
	}
}

#[asynchronous]
pub trait TaskExtensions: Task + Sized {
	async fn map<F, Output>(self, map: F) -> F::Output
	where
		F: AsyncFnOnce<Output>,
		Self: for<'ctx> Task<Output<'ctx> = Output>
	{
		map.call_once(self.await).await
	}
}

impl<T: Task> TaskExtensions for T {}

/// Get the current async context
///
/// `'current` is a lifetime that is valid for the current async function, and
/// as such cannot be used outside the function
///
/// To return a lifetime referencing the context, add
/// `#[cx]` to the lifetime you wish to use,
/// as the lifetime of the context
///
/// See also [`scoped`]
#[asynchronous]
#[lang = "get_context"]
pub async fn get_context() -> &'current Context {
	/* compiler builtin */
}

/// # Safety
/// The current routine must be allowed to suspend
/// This must be allowed in any async function
///
/// In synchronous functions, it is allowed to suspend
/// if all references are allowed to cross an await barrier
pub unsafe fn scoped<T, Output>(context: &Context, task: T) -> Output
where
	T: for<'ctx> Task<Output<'ctx> = Output>
{
	/* Safety: guaranteed by caller */
	unsafe { context.run(task) }
}

/// Block on a `Future`, suspending until it completes
#[asynchronous]
#[inline]
pub async fn block_on<F>(future: F) -> F::Output
where
	F: Future
{
	/* Safety: we are in an async function */
	unsafe { get_context().await.block_on(future, false) }
}

/// Runs and blocks on future `F` which is expected to be completed from
/// another thread
///
/// # Panics
/// If the operation isn't supported by the current async runtime
#[asynchronous]
#[inline]
pub async fn block_on_thread_safe<F>(future: F) -> F::Output
where
	F: Future
{
	/* Safety: we are in an async function */
	unsafe { get_context().await.block_on(future, true) }
}

#[asynchronous]
pub async fn current_budget() -> u32 {
	get_context().await.current_budget() as u32
}

#[asynchronous]
#[allow(clippy::impl_trait_in_params)]
pub async fn acquire_budget(amount: impl Into<Option<u32>>) -> bool {
	let amount = amount.into().unwrap_or(1).try_into().unwrap_or(u16::MAX);

	get_context().await.decrease_budget(amount).is_some()
}

#[asynchronous]
pub async fn is_interrupted() -> bool {
	get_context().await.interrupted()
}

#[asynchronous]
pub async fn check_interrupt() -> Result<()> {
	if !is_interrupted().await {
		Ok(())
	} else {
		Err(ErrorKind::Interrupted.into())
	}
}

#[asynchronous]
pub async fn clear_interrupt() {
	get_context().await.clear_interrupt();
}

#[asynchronous]
pub async fn take_interrupt() -> bool {
	let interrupted = is_interrupted().await;

	if interrupted {
		clear_interrupt().await;
	}

	interrupted
}

#[asynchronous]
pub async fn check_interrupt_take() -> Result<()> {
	if !take_interrupt().await {
		Ok(())
	} else {
		Err(ErrorKind::Interrupted.into())
	}
}

/// Creates an interrupt guard
///
/// While this guard is held, any attempt to interrupt
/// the current context will be ignored
#[asynchronous]
pub async fn interrupt_guard<#[cx] 'current>() -> InterruptGuard<'current> {
	InterruptGuard::new(get_context().await)
}
