use std::marker::PhantomData;

use super::*;

#[doc(hidden)]
#[inline(always)]
pub fn as_task<T, Output>(task: T) -> impl for<'ctx> Task<Output<'ctx> = Output>
where
	T: for<'ctx> Task<Output<'ctx> = Output>
{
	task
}

#[doc(hidden)]
#[inline(always)]
pub fn unsafe_stub_do_not_use<T>(context: &Context, task: T) -> T::Output<'_>
where
	T: Task
{
	/* Safety: this function is a stub generated by macros only in an async
	 * function. it is an error to call this function from anywhere else
	 */
	unsafe { context.run(task) }
}

#[doc(hidden)]
#[asynchronous]
#[lang = "task_wrap"]
pub struct OpaqueTask<F, Output>(F, PhantomData<Output>);

#[doc(hidden)]
#[asynchronous]
#[lang = "task_closure"]
pub struct OpaqueClosure<F, Output>(F, PhantomData<Output>);

#[doc(hidden)]
#[asynchronous]
#[lang = "async_closure"]
pub struct OpaqueAsyncFn<F, const T: usize>(F);

#[cfg(any(doc, feature = "xx-doc"))]
/// Additional bound for async traits only while generating documentation
///
/// Async traits generated by the [`asynchronous`] macro are usually object
/// safe, but the docs may say otherwise
pub trait DocDynSafe: Sized {}
